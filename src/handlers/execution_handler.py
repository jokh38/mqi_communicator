"""
Provides a unified handler for executing commands and transferring files
either locally or on a remote machine, driven by configuration settings.
"""

import os
import re
import shutil
import subprocess
from pathlib import Path
from typing import Any, NamedTuple, Optional

import paramiko

from src.config.settings import Settings
from src.infrastructure.logging_handler import LoggerFactory


class ExecutionResult(NamedTuple):
    """A structured result from a command execution."""
    success: bool
    output: str
    error: str
    return_code: int


class JobSubmissionResult(NamedTuple):
    """Result from a job submission, including a potential job ID."""
    success: bool
    job_id: Optional[str] = None
    error: Optional[str] = None


class UploadResult(NamedTuple):
    """Result from a file upload operation."""
    success: bool
    error: Optional[str] = None


class DownloadResult(NamedTuple):
    """Result from a file download operation."""
    success: bool
    error: Optional[str] = None


class ExecutionHandler:
    """
    A simplified handler that executes commands generated by the Settings class.
    """

    def __init__(self,
                 settings: Settings,
                 mode: str,
                 ssh_client: Optional[paramiko.SSHClient] = None):
        """
        Initializes the ExecutionHandler.
        """
        if mode not in ["local", "remote"]:
            raise ValueError("Mode must be either 'local' or 'remote'")
        if mode == "remote" and not ssh_client:
            raise ValueError("ssh_client is required for 'remote' mode")

        self.settings = settings
        self.mode = mode
        self._ssh_client = ssh_client
        self._sftp_client: Optional[paramiko.SFTPClient] = None
        self.logger = LoggerFactory.get_logger("ExecutionHandler")

    def execute_command(self,
                        command: str,
                        cwd: Optional[Path] = None) -> ExecutionResult:
        """
        Executes a command either locally or remotely.
        """
        if self.mode == "local":
            try:
                result = subprocess.run(command,
                                        shell=True,
                                        check=True,
                                        capture_output=True,
                                        text=True,
                                        cwd=cwd)
                return ExecutionResult(success=True,
                                       output=result.stdout,
                                       error=result.stderr,
                                       return_code=result.returncode)
            except subprocess.CalledProcessError as e:
                return ExecutionResult(success=False,
                                       output=e.stdout,
                                       error=e.stderr,
                                       return_code=e.returncode)
        else:  # remote
            if not self._ssh_client:
                raise ConnectionError("SSH client not available for remote execution.")
            full_command = f"cd {cwd} && {command}" if cwd else command
            stdin, stdout, stderr = self._ssh_client.exec_command(full_command)
            exit_code = stdout.channel.recv_exit_status()
            return ExecutionResult(success=exit_code == 0,
                                   output=stdout.read().decode("utf-8"),
                                   error=stderr.read().decode("utf-8"),
                                   return_code=exit_code)

    def submit_simulation_job(self, handler_name: str, command_key: str,
                              **context: Any) -> JobSubmissionResult:
        """
        Submits a simulation job using a specific command key from the Settings.
        """
        try:
            command = self.settings.get_command(command_key,
                                                handler_name=handler_name,
                                                **context)
            result = self.execute_command(command)
            if not result.success:
                return JobSubmissionResult(success=False, error=result.error)
            match = re.search(r"(\d+)$", result.output.strip())
            if match:
                return JobSubmissionResult(success=True, job_id=match.group(1))
            return JobSubmissionResult(
                success=False,
                error="Could not extract job ID from command output.")
        except (KeyError, ValueError) as e:
            return JobSubmissionResult(success=False, error=str(e))

    def post_process(self, handler_name: str, **context: Any) -> ExecutionResult:
        """
        Runs a post-processing command obtained from Settings.
        """
        command = self.settings.get_command('post_process',
                                            handler_name=handler_name,
                                            **context)
        cwd = context.get('cwd')
        return self.execute_command(command, cwd=cwd)

    def upload_file(self, local_path: str, remote_path: str) -> UploadResult:
        """
        Uploads a file. In local mode, this is a copy.
        """
        try:
            if self.mode == "local":
                target_dir = os.path.dirname(remote_path)
                if target_dir:
                    os.makedirs(target_dir, exist_ok=True)
                shutil.copy(local_path, remote_path)
            else:  # remote
                if not self._ssh_client:
                    raise ConnectionError("SSH client not available for remote upload.")
                if not self._sftp_client:
                    self._sftp_client = self._ssh_client.open_sftp()
                self._mkdir_p(self._sftp_client, os.path.dirname(remote_path))
                self._sftp_client.put(local_path, remote_path)
            return UploadResult(success=True)
        except Exception as e:
            self.logger.error("File upload failed", context={"error": str(e)})
            return UploadResult(success=False, error=str(e))

    def download_file(self, remote_path: str, local_path: str) -> DownloadResult:
        """
        Downloads a file. In local mode, this is a copy.
        """
        try:
            local_dir = os.path.dirname(local_path)
            if local_dir:
                os.makedirs(local_dir, exist_ok=True)

            if self.mode == "local":
                shutil.copy(remote_path, local_path)
            else:  # remote
                if not self._ssh_client:
                    raise ConnectionError("SSH client not available for remote download.")
                if not self._sftp_client:
                    self._sftp_client = self._ssh_client.open_sftp()
                self._sftp_client.get(remote_path, local_path)
            return DownloadResult(success=True)
        except Exception as e:
            self.logger.error("File download failed", context={"error": str(e)})
            return DownloadResult(success=False, error=str(e))

    def cleanup(self, handler_name: str, **context: Any) -> ExecutionResult:
        """
        Runs a cleanup command (e.g., 'rm -rf') from Settings.
        """
        command = self.settings.get_command("cleanup",
                                            handler_name=handler_name,
                                            **context)
        return self.execute_command(command)

    def upload_to_pc_localdata(self, handler_name: str, **context: Any) -> ExecutionResult:
        """
        Uploads results by executing a command from Settings.
        """
        command = self.settings.get_command("upload_result",
                                            handler_name=handler_name,
                                            **context)
        return self.execute_command(command)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self._sftp_client:
            self._sftp_client.close()

    def _mkdir_p(self, sftp: paramiko.SFTPClient, remote_directory: str):
        """
        Creates a directory and all its parents recursively on the remote server.
        This is a more robust implementation that handles nested creation.
        """
        if remote_directory == "/":
            sftp.chdir("/")
            return
        if remote_directory == "":
            return
        try:
            sftp.chdir(remote_directory)  # Test if remote_directory exists
        except IOError:
            dirname, basename = os.path.split(remote_directory.rstrip("/"))
            self._mkdir_p(sftp, dirname)
            sftp.mkdir(basename)
            sftp.chdir(basename)
            return True